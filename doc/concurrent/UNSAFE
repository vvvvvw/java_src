//https://www.cnblogs.com/mickole/articles/3757278.html

//构造方法私有化
private Unsafe() {}
//采用饿汉式单例
private static final Unsafe theUnsafe = new Unsafe();

//获取实例对象
public static Unsafe getUnsafe() {
    //获取调用该方法的调用者信息
    Class<?> caller = Reflection.getCallerClass();
    //判断该调用这的类加载器是否是系统类加载器(系统类加载器为null)
    if (!VM.isSystemDomainLoader(caller.getClassLoader()))
        throw new SecurityException("Unsafe");
    return theUnsafe;
}

//返回一个静态字段的偏移量
public native long staticFieldOffset(Field f);

//返回一个非静态字段字段的偏移量
public native long objectFieldOffset(Field f);

//获取给定对象指定偏移量的int值
public native int getInt(Object o, long offset);

//把给定对象指定偏移量上的值设置为整型变量ｘ
public native void putInt(Object o, long offset, int x);

//获取给定内存地址上的byte值
public native byte    getByte(long address);

//把给定内存地址上的值设置为byte值ｘ
public native void    putByte(long address, byte x);

//获取给定内存地址上的值，该值是表示一个内存地址
public native long getAddress(long address);

//分配一块本地内存，这块内存的大小便是给定的大小．这块内存的值是没有被初始化的
public native long allocateMemory(long bytes);

//定义一个类
public native Class<?> defineClass(String name, byte[] b, int off, int len,
                                       ClassLoader loader,
                                       ProtectionDomain protectionDomain);

//定义一个匿名类
public native Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches);

//获取给定对象上的锁（jvm中有monitorenter 和 monitorexit两个指令）
public native void monitorEnter(Object o);

//释放给定对象上的锁（jvm中有monitorenter 和 monitorexit
public native void monitorExit(Object o);

//CAS操作，修改对象指定偏移量上的（CAS简介见末尾）
public final native boolean compareAndSwapObject(Object o, long offset,
                                                 Object expected,
                                                 Object x);

//CAS操作
public final native boolean compareAndSwapInt(Object o, long offset,
                                                  int expected,
                                                  int x);

//CAS操作
public final native boolean compareAndSwapLong(Object o, long offset,
                                                   long expected,
                                                   long x);

//获取被volatile关键字修饰的字段的值
public native Object getObjectVolatile(Object o, long offset);

//取消阻塞线程 thread,如果 thread 已经是非阻塞状态，
//那么下次对该 thread 进行park操作时就不会阻塞
public native void unpark(Object thread);

//阻塞当前线程，isAbsolute的作用不是很清楚．（如果该方法调用前在线程非阻塞情况下调用了unpart方法，那么此次调用该方法不会令当前线程阻塞）
public native void park(boolean isAbsolute, long time);

//CAS操作
public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!compareAndSwapInt(o, offset, v, v + delta));
        return v;
}

///--------------------- peek and poke 指令--------------
//获取对象o中给定偏移地址(offset)的值。以下相关get方法作用相同
public native int getInt(Object o, long offset);
//在对象o的给定偏移地址存储数值x。以下set方法作用相同
public native void putInt(Object o, long offset, int x);
public native Object getObject(Object o, long offset);
public native void putObject(Object o, long offset, Object x);
/**篇幅原因，省略其他类型方法 */
//从给定内存地址获取一个byte。下同
public native byte    getByte(long address);
//在给定内存地址放置一个x。下同
public native void    putByte(long address, byte x);
/**篇幅原因，省略其他类型方法*/
//获取给定内存地址的一个本地指针
public native long getAddress(long address);
//在给定的内存地址处存放一个本地指针x
public native void putAddress(long address, long x);

///------------------内存操作----------------------
//在本地内存分配一块指定大小的新内存，内存的内容未初始化;它们通常被当做垃圾回收。
public native long allocateMemory(long bytes);
//重新分配给定内存地址的本地内存
public native long reallocateMemory(long address, long bytes);
//将给定内存块中的所有字节设置为固定值（通常是0）
public native void setMemory(Object o, long offset, long bytes, byte value);
//复制一块内存，double-register模型
public native void copyMemory(Object srcBase, long srcOffset,
                              Object destBase, long destOffset,
                              long bytes);
//复制一块内存，single-register模型
public void copyMemory(long srcAddress, long destAddress, long bytes) {
    copyMemory(null, srcAddress, null, destAddress, bytes);
}
//释放给定地址的内存
public native void freeMemory(long address);
//获取给定对象的偏移地址
public native long staticFieldOffset(Field f);
public native long objectFieldOffset(Field f);

//------------------数组操作---------------------------------
//获取给定数组的第一个元素的偏移地址
public native int arrayBaseOffset(Class<?> arrayClass);
//获取给定数组的元素增量地址，也就是说每个元素的占位数
public native int arrayIndexScale(Class<?> arrayClass);

//------------------------------------------------------------
//告诉虚拟机去定义一个类。默认情况下，类加载器和保护域都来自这个方法
public native Class<?> defineClass(String name, byte[] b, int off, int len,
                                   ClassLoader loader,
                                   ProtectionDomain protectionDomain);
//定义匿名内部类
public native Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches);
//定位一个实例，但不运行构造函数
public native Object allocateInstance(Class<?> cls) throws InstantiationException;

///--------------------锁指令（synchronized）-------------------------------
//对象加锁
public native void monitorEnter(Object o);
//对象解锁
public native void monitorExit(Object o);
public native boolean tryMonitorEnter(Object o);
//解除给定线程的阻塞
public native void unpark(Object thread);
//阻塞当前线程
public native void park(boolean isAbsolute, long time);

// CAS
public final native boolean compareAndSwapObject(Object o, long offset,
                                                 Object expected,
                                                 Object x);
//获取对象o的给定偏移地址的引用值（volatile方式）
public native Object getObjectVolatile(Object o, long offset);
public native void    putObjectVolatile(Object o, long offset, Object x);
/** 省略其他类型方法  */

/*
putOrderedObject 是 lazySet 的实现，适用于低延迟代码。它能够实现非堵塞写入，避免指令重排序，
这样它使用快速的存储-存储(store-store) barrier,而不是较慢的存储-加载(store-load) barrier,
后者总是用在volatile的写操作上。这种性能提升是有代价的，也就是写后结果并不会被其他线程看到，
甚至是自己的线程，通常是几纳秒后被其他线程看到。类似的方法还有putOrderedInt、putOrderedLong。
*/
//用于lazySet，适用于低延迟代码。
public native void    putOrderedObject(Object o, long offset, Object x);
/** 省略其他类型方法  */
//获取并加上给定delta，返回加之前的值
public final int getAndAddInt(Object o, long offset, int delta)
/** 省略其他类型方法  */
//为给定偏移地址设置一个新的值，返回设置之前的值
public final int getAndSetInt(Object o, long offset, int newValue)
/** 省略其他类型方法  */

///--------------------1.8新增指令-----------------------
// loadFence() 表示该方法之前的所有load操作在内存屏障之前完成
public native void loadFence();
//表示该方法之前的所有store操作在内存屏障之前完成
public native void storeFence();
//表示该方法之前的所有load、store操作在内存屏障之前完成，这个相当于上面两个的合体功能
public native void fullFence();

作者：泰迪的bagwell
链接：https://www.jianshu.com/p/a897c4b8929f
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。